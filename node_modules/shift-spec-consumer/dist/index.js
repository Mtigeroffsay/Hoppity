/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

if (!Array.from) {
  Array.from = function (a) {
    var x = [];
    var y = void 0;
    while (y = a.next(), !y.done) {
      x.push(y.value);
    }
    return x;
  };
}
var webIDL = require('webidl2');

var nodes = void 0;
var enums = void 0;
var idlTypes = void 0;
var namedTypesIDL = void 0;
var namedTypes = void 0;
var valueTypes = void 0;

var spec = void 0;
var attrOrders = void 0;

function parseAttrOrder(f) {
  var attrOrder = new Map();
  var current = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = f.split('\n')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;

      line = line.trim();
      if (line === '') continue;
      if (line[0] === '[') {
        var matches = line.match(/^\[([^\]]*)\]$/);
        if (!matches) {
          throw new Error('Couldn\'t parse ' + line);
        }
        var type = matches[1];
        current = [];
        attrOrder.set(type, current);
      } else {
        current.push(line);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return attrOrder;
}

function unsortedArrayEquals(a, b) {
  if (a.length !== b.length) return false;
  var x = a.slice(0).sort();
  var y = b.slice(0).sort();
  return x.every(function (v, i) {
    return y[i] === v;
  });
}

function Nullable(t) {
  return { kind: 'nullable', argument: t };
}

function Union(t) {
  return { kind: 'union', argument: t };
}

function List(t) {
  return { kind: 'list', argument: t };
}

function Value(t) {
  return { kind: 'value', argument: t };
}

function Node(t) {
  return { kind: 'node', argument: t };
}

function NamedType(t) {
  return { kind: 'namedType', argument: t };
}

function Enum(t) {
  return { kind: 'enum', argument: t };
}

function isSimpleIdlType(type) {
  return !type.sequence && !type.generic && !type.nullable && !type.array && !type.union && typeof type.idlType === 'string';
}

function inherits(type, parent) {
  nodes.get(type).parents.push(parent);
}

function idlTypeToType(t) {
  // converts a type as returned by the parser to a type as defined above
  if (typeof t === 'string') {
    if (nodes.has(t)) {
      return Node(t);
    }
    if (valueTypes.has(t)) {
      return valueTypes.get(t);
    }
    if (namedTypes.has(t)) {
      return NamedType(t);
    }
    if (enums.has(t)) {
      return Enum(t);
    }
    throw new Error('Unidentified type ' + t);
  }

  if (isSimpleIdlType(t)) {
    return idlTypeToType(t.idlType);
  }

  if (t.nullable) {
    if (t.union) {
      if (t.sequence || t.generic || t.array || !Array.isArray(t.idlType)) {
        throw new Error('Complex nullable-union type ' + JSON.stringify(t, null, '  '));
      }
      return Nullable(Union(t.idlType.map(idlTypeToType)));
    }
    if (t.sequence || t.generic || t.array || t.union || typeof t.idlType !== 'string') {
      throw new Error('Complex nullable type ' + JSON.stringify(t, null, '  '));
    }
    return Nullable(idlTypeToType(t.idlType));
  }

  if (t.array === 1) {
    if (t.union) {
      if (t.sequence || t.generic || !Array.isArray(t.idlType)) {
        throw new Error('Complex array-of-union type ' + JSON.stringify(t, null, '  '));
      }
      if (t.nullableArray[0]) {
        return List(Nullable(Union(t.idlType.map(idlTypeToType))));
      }
      return List(Union(t.idlType.map(idlTypeToType)));
    }
    if (t.sequence || t.generic || typeof t.idlType !== 'string') {
      throw new Error('Complex array type ' + JSON.stringify(t, null, '  '));
    }
    if (t.nullableArray[0]) {
      return List(Nullable(idlTypeToType(t.idlType)));
    }
    return List(idlTypeToType(t.idlType));
  }

  if (t.union) {
    if (t.sequence || t.generic || t.array || !Array.isArray(t.idlType)) {
      throw new Error('Complex union type ' + JSON.stringify(t, null, '  '));
    }
    return Union(t.idlType.map(idlTypeToType));
  }

  throw new Error('Unsupported IDL type ' + JSON.stringify(t, null, '  '));
}

function setAttrs(name) {
  var type = nodes.get(name);
  if (type.attributes) return;
  var attrs = type.attributes = [];

  type.parents.forEach(function (p) {
    setAttrs(p);
    attrs.push.apply(attrs, _toConsumableArray(nodes.get(p).attributes.map(function (a) {
      return {
        name: a.name,
        type: a.type,
        inherited: true
      };
    })));
  });

  attrs.push.apply(attrs, _toConsumableArray(idlTypes.get(name).members.filter(function (t) {
    return t.name !== 'type';
  }).map(function (t) {
    return {
      name: t.name,
      type: idlTypeToType(t.idlType),
      inherited: false
    };
  })));
  var attrOrder = attrOrders.get(name);
  if (attrOrder === void 0) {
    throw new Error(name + ' does not have an attribute ordering specified');
  }
  if (!unsortedArrayEquals(attrOrder, attrs.map(function (a) {
    return a.name;
  }))) {
    throw new Error(name + '\'s ordered attribute list (' + JSON.stringify(attrOrder) + ') does not agree with the list of attributes derived from the IDL (' + JSON.stringify(attrs.map(function (a) {
      return a.name;
    })) + ')');
  }

  attrs.sort(function (a, b) {
    return attrOrder.indexOf(a.name) - attrOrder.indexOf(b.name);
  });
}

module.exports = function (shiftSpecIdl, shiftSpecAttributeOrdering) {

  nodes = new Map();
  enums = new Map();
  idlTypes = new Map();
  namedTypesIDL = new Map();
  namedTypes = new Map();
  valueTypes = new Map([['string', Value('string')], ['DOMString', Value('string')], ['boolean', Value('boolean')], ['double', Value('double')]]);

  spec = webIDL.parse(shiftSpecIdl);
  attrOrders = parseAttrOrder(shiftSpecAttributeOrdering);

  // First set up the types
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = spec[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var type = _step2.value;

      if (type.type === 'interface') {
        idlTypes.set(type.name, type);
        if (nodes.has(type.name) || namedTypesIDL.has(type.name) || enums.has(type.name)) {
          throw new Error('Overloaded type ' + type.name);
        }
        nodes.set(type.name, {
          children: [],
          parents: []
        });
        if (type.inheritance !== null) {
          inherits(type.name, type.inheritance);
        }
      } else if (type.type === 'implements') {
        inherits(type.target, type.implements);
      } else if (type.type === 'typedef') {
        if (type.name === 'string') {
          var alias = type.idlType;
          if (alias.idlType !== 'DOMString' || alias.sequence || alias.generic !== null || alias.nullable || alias.array || alias.union) {
            throw new Error('"string" type is not just an alias for DOMString');
          }
          continue;
        }
        if (nodes.has(type.name) || namedTypesIDL.has(type.name) || enums.has(type.name)) {
          throw new Error('Overloaded type ' + type.name);
        }
        namedTypesIDL.set(type.name, type.idlType);
      } else if (type.type === 'enum') {
        if (nodes.has(type.name) || namedTypesIDL.has(type.name) || enums.has(type.name)) {
          throw new Error('Overloaded type ' + type.name);
        }
        enums.set(type.name, type.values);
      } else {
        throw new Error('Unsupported type ' + type);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (!unsortedArrayEquals([].concat(_toConsumableArray(nodes.keys())), [].concat(_toConsumableArray(attrOrders.keys())))) {
    throw new Error('List of nodes from spec ' + [].concat(_toConsumableArray(nodes.keys())) + ' does not match list of nodes from attribute-order ' + [].concat(_toConsumableArray(attrOrders.keys())));
  }

  nodes.forEach(function (node, name) {
    node.parents.forEach(function (p) {
      nodes.get(p).children.push(name);
    });
  });

  namedTypesIDL.forEach(function (v, k) {
    namedTypes.set(k, idlTypeToType(v));
  });

  // Then set up the attributes for each type
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = nodes.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var name = _step3.value;

      setAttrs(name);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return { nodes: nodes, enums: enums, namedTypes: namedTypes };
};